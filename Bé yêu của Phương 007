// ==UserScript==
// @name         MENU HACK ULTIMATE
// @namespace    http://tampermonkey.net/
// @version      007
// @description  try to take over the world!
// @author       B√© y√™u c·ªßa Ph∆∞∆°ng
// @match        https://gtd-cdn.gamehollywood.com/GTD_service/index_gh.html*
// @icon         https://scontent.fsgn13-1.fna.fbcdn.net/v/t1.15752-9/540516309_639062835906402_6765122471826245385_n.jpg?stp=dst-jpg_p480x480_tt6&_nc_cat=110&ccb=1-7&_nc_sid=0024fc&_nc_ohc=xy7drsXhjOwQ7kNvwFmO698&_nc_oc=Adn295zQzrDOz04kCt4WkURjoETt4cgqDa7lnHgZNA3OPByGfgKCOYdKQC-d-t9zg89sreY-saCqt4RhYJs2vIKw&_nc_ad=z-m&_nc_cid=0&_nc_zt=23&_nc_ht=scontent.fsgn13-1.fna&oh=03_Q7cD3AGTiI-_CSbUBXZUwjC3wybG8IW-z7dFRKdUClvzUmU0ZA&oe=68D8A0B3
// @grant        none
// ==/UserScript==

(function() {
  'use strict';
  // ƒê·∫£m b·∫£o script ch·ªâ ch·∫°y m·ªôt l·∫ßn
  if (window.__ULTIMATE_MOD_LOADED__) return;
  window.__ULTIMATE_MOD_LOADED__ = true;

  let lokiPassAndHackMap = false, monthlyPackageAndBypass = false, originalGachaFn = null, originalDEFINE_MARKETSTORE_GOLD = null, originalDEFINE_MARKETSTORE_DIA = null, originalPVP = null;
  let eventMods = false, speedGachaMods = false, shopPvpMods = false, towerMods = false, heroMods = false;

  const HeroManager = {
    originalHeroBou: null,
    originalSelected: null,
    originalHeroSelectedMax: null,
    enable: function() {
      if (typeof STORAGE === "undefined" || !STORAGE.hero_bou) return;
      if (!this.originalHeroBou) this.originalHeroBou = JSON.parse(JSON.stringify(STORAGE.hero_bou));
      const heroLevels = {
        1: 180,
        31: 200,
        37: 1000000000000,
        43: 50,
        46: 60
      };
      for (let i = 1; i < 53; i++) {
        if (STORAGE.hero_bou[i]) {
          STORAGE.hero_bou[i].buy = 1;
          STORAGE.hero_bou[i].killexp = 0;
          let level = 60;
          for (const start in heroLevels) {
            if (i >= parseInt(start)) {
              level = heroLevels[start];
            }
          }
          STORAGE.hero_bou[i].level = level;
        }
      }
      if (typeof HERO_AWAKE !== "undefined") HERO_AWAKE.fenrir_color = "red";
      if (!this.originalSelected) this.originalSelected = { ...STORAGE.hero_selected
      };
      Object.assign(STORAGE.hero_selected, {
        1: 33,
        2: 40,
        3: 41,
        4: 38,
        5: 39
      });
      if (typeof STORAGE.hero_selected_max !== 'undefined') {
        if (!this.originalHeroSelectedMax) this.originalHeroSelectedMax = STORAGE.hero_selected_max;
        STORAGE.hero_selected_max = 5;
      }
      console.log("ü•∞ HackHero: heroes unlocked, leveled, and selected.");
    },
    disable: function() {
      if (this.originalHeroBou) STORAGE.hero_bou = JSON.parse(JSON.stringify(this.originalHeroBou));
      if (this.originalSelected) Object.assign(STORAGE.hero_selected, this.originalSelected);
      if (this.originalHeroSelectedMax && typeof STORAGE.hero_selected_max !== 'undefined') STORAGE.hero_selected_max = this.originalHeroSelectedMax;
      console.log("‚ùå HackHero: heroes restored.");
    }
  };
  const TowerManager = {
    originalTowerBou: null,
    enable: function() {
      if (!this.originalTowerBou) this.originalTowerBou = JSON.parse(JSON.stringify(STORAGE.tower_bou));
      const towerIDs = [6034, 6035, 6036, 6025, 6026, 6027];
      for (let i = 3; i < 9; i++) {
        STORAGE.tower_bou[i].card = 1;
        STORAGE.tower_bou[i].level = 1;
        STORAGE.tower_bou[i].tower_bunho_g = towerIDs[i - 3];
      }
      const ranges = [
        [5001, 5036],
        [4001, 4033],
        [3001, 3027],
        [2001, 2027],
        [1001, 1027]
      ];
      let index = 9;
      for (let [start, end] of ranges) {
        for (let id = start; id <= end; id++) {
          STORAGE.tower_bou[index] = {
            card: 0,
            level: 5,
            tower_bunho_g: id
          };
          index++;
        }
      }
      console.log("[HackTower] ƒê√£ b·∫≠t (1001‚Üí5036)");
    },
    disable: function() {
      if (this.originalTowerBou) {
        STORAGE.tower_bou = JSON.parse(JSON.stringify(this.originalTowerBou));
        console.log("[HackTower] ƒê√£ t·∫Øt, tr·∫£ v·ªÅ g·ªëc");
      }
    }
  };
  const TowerBuffManager = {
    originalTowerDefs: null,
    apply: function() {
      if (!this.originalTowerDefs) {
        this.originalTowerDefs = {};
        const lists = ['TOWER_D', 'TOWER_C', 'TOWER_B', 'TOWER_A', 'TOWER_S', 'TOWER_SS'];
        for (const name of lists) {
          try {
            const arr = window[name];
            if (arr && Array.isArray(arr)) this.originalTowerDefs[name] = JSON.parse(JSON.stringify(arr));
          } catch (e) {}
        }
      }
      const towerArrays = [window.TOWER_D, window.TOWER_C, window.TOWER_B, window.TOWER_A, window.TOWER_S, window.TOWER_SS];
      for (const arr of towerArrays) {
        if (!arr) continue;
        for (let i = 1; i < arr.length; i++) {
          try {
            if (!arr[i]) continue;
            arr[i].AP = 1000000000;
            arr[i].HP = 1000000000;
            arr[i].ATTACK_PERCENT = 100;
            arr[i].AW = 0;
            arr[i].RADIUS = 1500;
            arr[i].MINERAL_BUILD = -1000000;
          } catch (e) {}
        }
      }
      console.log("ü•∞ TowerBuff applied to TOWER_* arrays.");
    },
    disable: function() {
      if (this.originalTowerDefs) {
        for (const name in this.originalTowerDefs) {
          try {
            if (window[name] && Array.isArray(window[name])) {
              const orig = this.originalTowerDefs[name];
              for (let i = 0; i < orig.length && i < window[name].length; i++) {
                if (!orig[i] || !window[name][i]) continue;
                try {
                  const keys = Object.keys(orig[i]);
                  for (const k of Object.keys(window[name][i])) {
                    if (!orig[i].hasOwnProperty(k)) {
                      try {
                        delete window[name][i][k];
                      } catch (_) {}
                    }
                  }
                  for (const k of keys) {
                    try {
                      window[name][i][k] = JSON.parse(JSON.stringify(orig[i][k]));
                    } catch (_) {
                      window[name][i][k] = orig[i][k];
                    }
                  }
                } catch (_) {}
              }
            }
          } catch (_) {}
        }
        console.log("ü•∞ TowerBuff: attempted to restore original TOWER_* arrays from saved copy.");
      } else {
        console.log("‚ö†Ô∏è TowerBuff: no original snapshot available, cannot fully restore without reload.");
      }
    }
  };

  function overrideStore() {
    if (typeof window.DEFINE === 'undefined') return;
    if (!originalDEFINE_MARKETSTORE_GOLD) originalDEFINE_MARKETSTORE_GOLD = JSON.parse(JSON.stringify(window.DEFINE.MARKETSTORE_GOLD));
    if (!originalDEFINE_MARKETSTORE_DIA) originalDEFINE_MARKETSTORE_DIA = JSON.parse(JSON.stringify(window.DEFINE.MARKETSTORE_DIA));
    window.DEFINE.MARKETSTORE_GOLD = [{}, {
      title: "Í≥®Îìú<br>100,000,000",
      gold: 100000000,
      payruby: 10,
      TAG: 0
    }, {
      title: "Í≥®Îìú<br>330,000,000",
      gold: 330000000,
      payruby: 10,
      TAG: 0
    }, {
      title: "Í≥®Îìú<br>840,000,000",
      gold: 840000000,
      payruby: 10,
      TAG: 0
    }, {
      title: "Í≥®Îìú<br>31,500,000,000",
      gold: 31500000000,
      payruby: 10,
      TAG: 0
    }];
    window.DEFINE.MARKETSTORE_DIA = [{}, {
      title: "Îã§Ïù¥ÏïÑ<br>100,000Í∞ú",
      magic: 100000,
      payruby: 10
    }, {
      title: "Îã§Ïù¥ÏïÑ<br>550,000Í∞ú",
      dia: 550000,
      payruby: 10
    }, {
      title: "Îã§Ïù¥ÏïÑ<br>1,150,000Í∞ú",
      dia: 1150000,
      payruby: 10
    }, {
      title: "Îã§Ïù¥ÏïÑ<br>3,600,000Í∞ú",
      dia: 3600000,
      payruby: 10
    }];
    console.log('[Tampermonkey] HackShop packages overridden.');
  }

  function restoreStore() {
    if (typeof window.DEFINE === 'undefined') return;
    if (originalDEFINE_MARKETSTORE_GOLD) {
      window.DEFINE.MARKETSTORE_GOLD = JSON.parse(JSON.stringify(originalDEFINE_MARKETSTORE_GOLD));
      console.log('[Tampermonkey] HackShop packages restored.');
    }
    if (originalDEFINE_MARKETSTORE_DIA) {
      window.DEFINE.MARKETSTORE_DIA = JSON.parse(JSON.stringify(originalDEFINE_MARKETSTORE_DIA));
      console.log('[Tampermonkey] HackShop packages restored.');
    }
  }

  function overridePVPFunc() {
    if (typeof PVP === "undefined" || typeof ENUM === "undefined" || typeof IMAGE_FOR_PVP === "undefined") return;
    if (!originalPVP) originalPVP = JSON.parse(JSON.stringify(PVP));
    PVP = {
      status: ENUM.PVP_STATUS.NONE,
      fname_size: IMAGE_FOR_PVP.length - 1,
      MAX_ATTACK_POINT: 15e4,
      attack_point: 0,
      attack_mode: 0,
      attack_focus: 1,
      monster_send_num: 0,
      ATTACK: [{}, {
        enemy_bunho: 104,
        need_point: 0
      }, {
        enemy_bunho: 108,
        need_point: 0
      }, {
        enemy_bunho: 109,
        need_point: 0
      }, {
        enemy_bunho: 110,
        need_point: 0
      }, {
        enemy_bunho: 111,
        need_point: 0
      }, {
        enemy_bunho: 112,
        need_point: 0
      }, {
        enemy_bunho: 113,
        need_point: 0
      }, {
        enemy_bunho: 114,
        need_point: 0
      }],
      fenrir_color: "",
      fenrir_level: 0
    };
    console.log("ü•∞ PVP ƒë√£ b·ªã ghi ƒë√®!");
  }

  function restorePVPFunc() {
    if (typeof PVP === "undefined") return;
    if (originalPVP) {
      PVP = JSON.parse(JSON.stringify(originalPVP));
      console.log("üôÇ PVP ƒë√£ ƒë∆∞·ª£c kh√¥i ph·ª•c!");
    }
  }

  function applyTowerMods() {
    TowerManager.enable();
    TowerBuffManager.apply();
  }

  function disableTowerMods() {
    TowerManager.disable();
    TowerBuffManager.disable();
  }
  const HackSpeedManager = {
    originalIntervalMsX1: null,
    originalIntervalMsX2: null,
    apply: function() {
      if (typeof window.INTERVAL_MS_x1 === 'undefined' || typeof window.INTERVAL_MS_x2 === 'undefined') {
        console.warn("[HackSpeed] INTERVAL_MS_x1 ho·∫∑c x2 kh√¥ng t·ªìn t·∫°i.");
        return;
      }
      if (this.originalIntervalMsX1 === null) this.originalIntervalMsX1 = window.INTERVAL_MS_x1;
      if (this.originalIntervalMsX2 === null) this.originalIntervalMsX2 = window.INTERVAL_MS_x2;
      window.INTERVAL_MS_x1 = 9999;
      window.INTERVAL_MS_x2 = 9999;
      console.log('[HackSpeed] INTERVAL_MS_x1 v√† x2 ƒë√£ ƒë∆∞·ª£c ch·ªânh th√†nh 9999');
    },
    disable: function() {
      if (this.originalIntervalMsX1 !== null && typeof window.INTERVAL_MS_x1 !== 'undefined') window.INTERVAL_MS_x1 = this.originalIntervalMsX1;
      if (this.originalIntervalMsX2 !== null && typeof window.INTERVAL_MS_x2 !== 'undefined') window.INTERVAL_MS_x2 = this.originalIntervalMsX2;
      console.log('[HackSpeed] INTERVAL_MS_x1 v√† x2 ƒë√£ ƒë∆∞·ª£c kh√¥i ph·ª•c.');
    }
  };
  const HackEventShopManager = {
    originalEventMenuShopping: null,
    originalShopping: null,
    apply: function() {
      if (!window.S_EVENTMENU_SHOP ?.shopping || !window.PHP ?.eventmenu_shopping) {
        console.warn("[HackEventShop] Kh√¥ng t√¨m th·∫•y S_EVENTMENU_SHOP.shopping ho·∫∑c PHP.eventmenu_shopping.");
        return;
      }
      if (!this.originalEventMenuShopping) this.originalEventMenuShopping = PHP.eventmenu_shopping;
      if (!this.originalShopping) this.originalShopping = S_EVENTMENU_SHOP.shopping;
      PHP.eventmenu_shopping = function(n, rname, money, cb) {
        HackEventShopManager.originalEventMenuShopping.call(this, n, rname, money, function(serverResp) {
          console.log("[Hook Shop] Fake server response OK cho s·∫£n ph·∫©m", n);
          if (typeof cb === "function") cb(serverResp || {});
        });
      };
      S_EVENTMENU_SHOP.shopping = function(n) {
        const t = S_EVENTMENU_SHOP.event_menu_ui;
        t.remain["product" + n] = 9999;
        t.remain["PRODUCT" + n] = 9999;
        HackEventShopManager.originalShopping.call(this, n);
        const bonusMoney = 2000;
        const bonusCount = 1;
        t.remain_event_money += bonusMoney;
        PHP.getput_eventmoney({
          ADD: bonusMoney,
          ADD_WHY: "Event Shop Hook"
        }, function() {
          console.log(`[Hook Shop] C·ªông th√™m ${bonusMoney} EVENT_MONEY`);
        });
        t.remain["PRODUCT" + n] += bonusCount;
        console.log(`[Hook Shop] C·ªông th√™m ${bonusCount} l∆∞·ª£t s·∫£n ph·∫©m ${n}`);
      };
      console.log("[Hook Shop] Hook th√†nh c√¥ng!");
    },
    disable: function() {
      if (this.originalEventMenuShopping && PHP.eventmenu_shopping) PHP.eventmenu_shopping = this.originalEventMenuShopping;
      if (this.originalShopping && S_EVENTMENU_SHOP.shopping) S_EVENTMENU_SHOP.shopping = this.originalShopping;
      console.log("[Hook Shop] Hook ƒë√£ t·∫Øt.");
    }
  };

  const lokiPassBypass = (function() {
    const fakeOK = function(callback) {
      console.log("[Bypass] Injecting fake Myths data as OK");
      S_MYTHS_TOP.pass_enddate = "2099-12-31 23:56:45";
      if (callback) callback();
    };
    const originalGetMythsData = PHP.get_myths_data;
    const apply = () => {
      PHP.get_myths_data = function(n, t) {
        try {
          originalGetMythsData.call(PHP, n, function() {
            fakeOK(t);
          });
        } catch (e) {
          console.warn("[Bypass] Error calling original, injecting fake data directly:", e);
          fakeOK(t);
        }
      };
      console.log("‚úÖ Loki Pass Bypass enabled.");
    };
    const disable = () => {
      PHP.get_myths_data = originalGetMythsData;
      console.log("‚ùå Loki Pass Bypass disabled.");
    };
    return {
      apply,
      disable
    };
  })();

  (function() {
    const open = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function(method, url, async, user, pass) {
      this.addEventListener('load', function() {
        if (this.responseURL.includes('get_user_payinfo.php')) {
          let response;
          try {
            response = JSON.parse(this.responseText);
          } catch (e) {
            return;
          }
          if (response.RESULT === "OK" && response.VALUE && response.VALUE.payinfo) {
            response.VALUE.payinfo.value = {
              daily_package_gold: "1",
              daily_package_rainbow: "1",
              beginner_package: "1",
              wow_package: "1",
              elijahA_package: "1",
              elijahB_package: "1",
              item_package: "1",
              hero_package_date: "2025-08-15 02:30:30",
              bundle_package_date: "2025-08-15 02:30:30",
              bundle_package: "1",
              monthly_pay_is: 1,
              monthly_pay_accday: 0,
              monthly_pay_accmon: 3,
              what_monthly_pay: 11000,
              monthly_pay_init_date: "2025-08-14 16:17:26",
              pay_total_this_month: 0,
              pay_limit_this_month: "2025-08-14 16:17:26"
            };
            Object.defineProperty(this, 'responseText', {
              value: JSON.stringify(response)
            });
          }
        }
        if (window.STORAGE && STORAGE.payinfo) {
          STORAGE.payinfo.beginner_package = 1;
          STORAGE.payinfo.monthly_pay_accmon = 3;
          STORAGE.payinfo.what_monthly_pay = 11000;
          STORAGE.payinfo.monthly_pay_init_date = '2025-07-17 16:17:26';
          STORAGE.payinfo.monthly_end_date = 17553286460;
          STORAGE.payinfo.monthly_item_name = 'Ï¥àÎ≥¥Ïûê Ìå®Ïä§Í∂å';
          STORAGE.payinfo.payor_user = 1;
          STORAGE.payinfo.loki_pass_end_date = 17553286460;
        }
      });
      open.apply(this, arguments);
    };
  })();

  function hackEventScan() {
    if (!eventMods) return;

    function maybePatch(obj, path) {
      try {
        for (const k of Object.keys(obj)) {
          const v = obj[k];
          if (k === 'use_ruby' && v === 200) obj[k] = 200;
          if (k === 'use_eventmoney' && v === 30) obj[k] = -30000;
          if (k === 'use_eventmoney' && v === 35000) obj[k] = 1;
        }
        if (path.endsWith('.remain')) {
          if (obj.PRODUCT1 !== undefined) obj.PRODUCT1 = "99999";
          if (obj.PRODUCT2 !== undefined) obj.PRODUCT2 = "99999";
          if (obj.PRODUCT3 !== undefined) obj.PRODUCT3 = 99999;
          if (obj.PRODUCT4 !== undefined) obj.PRODUCT4 = "99999";
        }
        if (path.endsWith('.txt')) {
          if (Array.isArray(obj.btn_txt)) obj.btn_txt = obj.btn_txt.map(() => 1);
        }
      } catch (_) {}
    }

    function scan(root, maxDepth = 6) {
      const seen = new WeakSet();
      const stack = [{
        obj: root,
        path: 'window',
        depth: 0
      }];
      while (stack.length) {
        const {
          obj,
          path,
          depth
        } = stack.pop();
        if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) continue;
        if (seen.has(obj)) continue;
        seen.add(obj);
        maybePatch(obj, path);
        if (depth >= maxDepth) continue;
        let keys = [];
        try {
          keys = Object.keys(obj);
        } catch (_) {}
        for (const key of keys) {
          let val;
          try {
            val = obj[key];
          } catch (_) {
            continue;
          }
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            stack.push({
              obj: val,
              path: `${path}.${key}`,
              depth: depth + 1
            });
          }
        }
      }
    }
    scan(window, 8);
  }

  const HackMap = {
    originalStageEasy: null,
    apply: function() {
      if (!this.originalStageEasy) {
        this.originalStageEasy = [...STORAGE.stage_easy];
      }
      if (STORAGE && STORAGE.stage_easy && STORAGE.stage_hard && STORAGE.stage_normal) {
        for (let i = 1; i < STORAGE.stage_easy.length; i++) {
          STORAGE.stage_easy[i] = "A";
          STORAGE.stage_hard[i] = "C";
          STORAGE.stage_normal[i] = "C";
        }
        console.log("‚úÖ HackMap: Stages cleared.");
      } else {
        console.warn("‚ö†Ô∏è HackMap: STORAGE.stage_easy, stage_hard, or stage_normal is undefined.");
      }
    },
    disable: function() {
      if (this.originalStageEasy) {
        STORAGE.stage_easy = [...this.originalStageEasy];
        console.log("‚ùå HackMap: Stages restored.");
      } else {
        console.warn("‚ö†Ô∏è HackMap: No original stage data to restore.");
      }
    }
  };

  const BypassNetWork = {
    originalHero: null,
    originalTower: null,
    apply: function() {
      if (typeof PHP === "undefined") return;

      if (!this.originalHero) this.originalHero = PHP.put_userinfo_hero;
      if (!this.originalTower) this.originalTower = PHP.put_userinfo_tower;

      PHP.put_userinfo_hero = (data) => {
        console.log("üö´ Ch·∫∑n g·ª≠i hero:", data);
        console.log("üì¶ JSON Hero:", JSON.stringify(data, null, 2));
      };

      PHP.put_userinfo_tower = (data) => {
        console.log("üö´ Ch·∫∑n g·ª≠i tower:", data);
        console.log("üì¶ JSON Tower:", JSON.stringify(data, null, 2));
      };

      console.log("‚úÖ BypassNetWork enabled");
    },

    disable: function() {
      if (this.originalHero) PHP.put_userinfo_hero = this.originalHero;
      if (this.originalTower) PHP.put_userinfo_tower = this.originalTower;
      console.log("‚ùå BypassNetWork disabled");
    }
  };

  const proxyList = [{
    host: '139.162.78.109',
    port: 8080
  }, {
    host: '92.67.186.210',
    port: 80
  }, {
    host: '209.121.164.50',
    port: 31147
  }, {
    host: '41.191.203.162',
    port: 80
  }, {
    host: '203.162.13.26',
    port: 6868
  }, {
    host: '27.79.155.78',
    port: 16000
  }, ];
  let currentProxyIndex = 0;

  function changeIP() {
    if (proxyList.length === 0) {
      console.log("‚ö†Ô∏è Kh√¥ng c√≥ proxy n√†o ƒë∆∞·ª£c c·∫•u h√¨nh. Vui l√≤ng th√™m proxy v√†o proxyList.");
      return false;
    }

    const proxy = proxyList[currentProxyIndex];
    currentProxyIndex = (currentProxyIndex + 1) % proxyList.length;

    const originalOpen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
      this.setRequestHeader('X-Forwarded-For', generateRandomIP());
      this.setRequestHeader('X-Real-IP', generateRandomIP());
      this.setRequestHeader('Via', 'proxy-server');

      return originalOpen.call(this, method, url, async, user, password);
    };

    console.log(`üåê ƒê√£ ƒë·ªïi IP qua proxy: ${proxy.host}:${proxy.port}`);
    return true;
  }

  function generateRandomIP() {
    return `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`;
  }

  function changeIPWithHeaders() {
    const originalFetch = window.fetch;
    window.fetch = function(url, options = {}) {
      options.headers = options.headers || {};
      options.headers['X-Forwarded-For'] = generateRandomIP();
      options.headers['X-Real-IP'] = generateRandomIP();
      options.headers['X-Client-IP'] = generateRandomIP();
      options.headers['CF-Connecting-IP'] = generateRandomIP();
      options.headers['True-Client-IP'] = generateRandomIP();

      return originalFetch.call(this, url, options);
    };

    console.log("üåê ƒê√£ th√™m headers ƒë·ªÉ gi·∫£ l·∫≠p IP m·ªõi");
  }

  function clearBrowserData() {
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.clear();
      chrome.storage.sync.clear();
    }

    localStorage.clear();
    sessionStorage.clear();

    console.log("üßπ ƒê√£ x√≥a cache v√† cookies");
  }

  function updateButtonStatus(button, text) {
    const originalText = button.textContent;
    button.textContent = text;
    button.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';

    setTimeout(() => {
      button.textContent = originalText;
      button.style.background = 'linear-gradient(45deg, #FF6B6B, #FF8E53)';
    }, 2000);
  }

  window.manualChangeIP = function(event) {
    if (typeof window.changeIP === 'function') {
      window.changeIP();
      if (event && event.target) {
        updateButtonStatus(event.target, 'ƒê√£ ƒë·ªïi IP!');
      }
    }
  };

  window.clearCache = function(event) {
    localStorage.clear();
    sessionStorage.clear();
    console.log("üßπ ƒê√£ x√≥a cache v√† cookies");
    if (event && event.target) {
      updateButtonStatus(event.target, 'ƒê√£ x√≥a!');
    }
  };

  window.changeIP = function() {
    changeIPWithHeaders();
    clearBrowserData();
    console.log("üîÑ IP ƒë√£ ƒë∆∞·ª£c thay ƒë·ªïi th·ªß c√¥ng");
  };

  setInterval(() => {
    changeIPWithHeaders();
  }, 5 * 60 * 1000);

  changeIPWithHeaders();
  console.log("üåê T√≠nh nƒÉng ƒë·ªïi IP ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t");

  // =========================================================================
  // PH·∫¶N GIAO DI·ªÜN V√Ä LOGIC CHUY·ªÇN ƒê·ªîI
  // =========================================================================

  const hackSettings = {
    eventMods: false,
    speedGachaMods: false,
    shopPvpMods: false,
    towerMods: false,
    heroMods: false,
    lokiPassAndHackMap: false,
    monthlyPackageAndBypass: false,
  };

  const hackOptions = [
    { key: "blockAndFixAwk", label: "Awaken", desc: "B·∫≠t/T·∫Øt Awaken", type: "toggle" },
    { key: "eventMods", label: "Event Mods ban", desc: "B·∫≠t/T·∫Øt Event Mods", type: "toggle" },
    { key: "speedGachaMods", label: "Speed/Gacha Mods", desc: "B·∫≠t/T·∫Øt Speed/Gacha Mods", type: "toggle" },
    { key: "shopPvpMods", label: "Shop/PvP Mods", desc: "B·∫≠t/T·∫Øt Shop/PvP Mods", type: "toggle" },
    { key: "towerMods", label: "Tower Mods", desc: "B·∫≠t/T·∫Øt Tower Mods", type: "toggle" },
    { key: "heroMods", label: "Hero Mods", desc: "B·∫≠t/T·∫Øt Hero Mods", type: "toggle" },
    { key: "lokiPassAndHackMap", label: "LokiPass + HackMap", desc: "B·∫≠t/T·∫Øt LokiPass + HackMap", type: "toggle" },
    { key: "monthlyPackageAndBypass", label: "G√≥i Th√°ng + Bypass", desc: "B·∫≠t/T·∫Øt G√≥i Th√°ng + Bypass", type: "toggle" },
    { key: "youtubeMusic", label: "üéµ Ultimate Music", desc: "YouTube", type: "youtube" },
    { key: "manualIPChange", label: "üîÑƒê·ªïi IP Change", desc: "ƒê·ªïi IP th·ªß c√¥ng", type: "button", action: "manualChangeIP(event)" },
    { key: "clearCache", label: "üßπ Clear Cache", desc: "X√≥a cache & cookies", type: "button", action: "clearCache(event)" }
  ];

  // ======== FUNCTIONS =========
  window.toggleHack = function(key, event) {
    event.stopPropagation();
    const toggleButton = event.target;
    hackSettings[key] = !hackSettings[key];
    if (hackSettings[key]) toggleButton.classList.add('active');
    else toggleButton.classList.remove('active');
  };

  window.manualChangeIP = function(event) { event.stopPropagation(); alert("ƒê√£ ƒë·ªïi IP th√†nh c√¥ng!"); };
  window.clearCache = function(event) { event.stopPropagation(); alert("ƒê√£ x√≥a cache & cookies!"); };

  function createHackItem(option) {
    if(option.type === "toggle"){
        return `
            <div class="hack-item">
                <div style="flex-grow: 1;">
                    <div class="hack-item-label">${option.label}</div>
                    <div class="hack-status">${option.desc}</div>
                </div>
                <div class="hack-toggle ${hackSettings[option.key] ? 'active' : ''}" onclick="toggleHack('${option.key}', event)"></div>
            </div>`;
    } else if(option.type === "button"){
        return `
            <div class="hack-item">
                <div style="flex-grow: 1;">
                    <div class="hack-item-label">${option.label}</div>
                    <div class="hack-status">${option.desc}</div>
                </div>
                <button class="hack-button" onclick="${option.action}">Click</button>
            </div>`;
    } else if (option.type === "youtube") {
        const videoId = "chgun6UHuWU";
        return `
            <div class="hack-item" style="display: flex; flex-direction: column; align-items: flex-start;">
                <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                    <div style="flex-grow: 1;">
                        <div class="hack-item-label">üéµ Ultimate Music</div>
                        <div class="hack-status">YouTube</div>
                    </div>
                </div>
                <iframe width="100%" height="150" src="https://www.youtube.com/embed/${videoId}?autoplay=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            </div>
        `;
    }
}
  // ======== STYLE =========
  const style = document.createElement('style');
  style.textContent = `
      .hack-panel {
          position: fixed;
          top: 10px; left: 10px;
          width: 280px; background: linear-gradient(45deg, #8A2BE2, #DC143C);
          border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
          z-index: 999999; font-family: 'Segoe UI', sans-serif;
          color: white; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2);
          transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
          overflow: hidden;
      }
      .hack-content {
          display: flex; /* B·∫≠t Flexbox */
          flex-direction: column; /* S·∫Øp x·∫øp c√°c m·ª•c theo c·ªôt (h√†ng d·ªçc) */
          padding: 20px;
          max-height: 350px;
          overflow-y: auto;
      }
      .hack-item {
          /* ƒê·∫£m b·∫£o c√°c m·ª•c con chi·∫øm to√†n b·ªô chi·ªÅu r·ªông */
          width: 90%;
          margin-bottom: 15px;
          padding: 10px;
          background: rgba(255,255,255,0.1);
          border-radius: 8px;
          transition: all 0.3s ease;
          display: flex;
          justify-content: space-between;
          align-items: center;
      }
      .hack-header {
          background: rgba(0,0,0,0.2);
          padding: 15px;
          border-radius: 15px 15px 0 0;
          display: flex;
          justify-content: space-between;
          align-items: center;
          cursor: grab;
      }
      .hack-title {
          font-size: 18px;
          font-weight: bold;
          text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      }
      .hack-avatar {
          width: 40px;
          height: 40px;
          border-radius: 50%;
          background: url('https://scontent.fsgn13-2.fna.fbcdn.net/v/t1.15752-9/522673438_1111231257117108_58499437148240754_n.png?stp=dst-png_p480x480&_nc_cat=106&ccb=1-7&_nc_sid=0024fc&_nc_ohc=4LSrWdPN3XUQ7kNvwEmTfIB&_nc_oc=AdmMqEPAbucHZ_dm96ftIuog6Ah24vup5PnjlCoNlIEMZVTFGl1MSlDNz-NivxcIomI-QYqfanwiOQtsg4E74hYJ&_nc_ad=z-m&_nc_cid=0&_nc_zt=23&_nc_ht=scontent.fsgn13-2.fna&oh=03_Q7cD3AEH2T_jWy5rWt2c2bIIjmuEtLxEfHd5-zrj7nDPWRDOqA&oe=68D8CE93') center/cover;
          box-shadow: 0 0 10px rgba(0,0,0,0.3);
          cursor: pointer;
      }
      .hack-item:hover {
          background: rgba(255,255,255,0.2);
          transform: translateX(-5px);
      }
      .hack-item-label {
          font-size: 14px;
          font-weight: 500;
      }
      .hack-toggle {
          width: 50px;
          height: 25px;
          background: rgba(255,255,255,0.3);
          border-radius: 25px;
          position: relative;
          cursor: pointer;
          transition: .3s;
      }
      .hack-toggle.active {
          background: #4CAF50;
      }
      .hack-toggle::after {
          content: '';
          position: absolute;
          top: 2px;
          left: 2px;
          width: 21px;
          height: 21px;
          background: white;
          border-radius: 50%;
          transition: .3s;
          box-shadow: 2px 2px 4px rgba(0,0,0,.2);
      }
      .hack-toggle.active::after {
          transform: translateX(25px);
      }
      .hack-status {
          font-size: 11px;
          opacity: .8;
          margin-top: 5px;
      }
      .hack-button {
          background: linear-gradient(45deg, #FF6B6B, #FF8E53);
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 20px;
          cursor: pointer;
          font-size: 12px;
          font-weight: bold;
      }
      .hack-panel.minimized {
          width: 60px !important;
          height: 60px !important;
          border-radius: 50% !important;
          padding: 0;
          overflow: hidden;
          background: transparent;
      }
      .hack-panel.minimized .hack-header {
          width: 100%;
          height: 100%;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: grab;
          background: transparent;
          padding: 0;
      }
      .hack-panel.minimized .hack-avatar {
          width: 60px;
          height: 60px;
          background-size: cover;
          background-position: center;
          box-shadow: 0 0 10px rgba(0,0,0,0.3);
          margin: 0;
      }
      .hack-panel.minimized .hack-content, .hack-panel.minimized .hack-title {
          display: none !important;
      }
  `;
  document.head.appendChild(style);

  // ======== CREATE PANEL =========
  const hackPanelElem = document.createElement('div');
  hackPanelElem.className = 'hack-panel';
  hackPanelElem.innerHTML = `
    <div class="hack-header">
      <div class="hack-avatar"></div>
      <div class="hack-title">ü•∞B√© y√™u c·ªßa Ph∆∞∆°ng</div>
    </div>
    <div class="hack-content">${hackOptions.map(createHackItem).join('')}</div>
  `;
  document.body.appendChild(hackPanelElem);

  // ======== MINIMIZE / MAXIMIZE =========
  let isMinimized = false;
  hackPanelElem.querySelector('.hack-avatar').addEventListener('click', ()=>{
    isMinimized = !isMinimized;
    hackPanelElem.classList.toggle('minimized', isMinimized);
  });

  // ======== DRAGGABLE =========
  const headerElem = hackPanelElem.querySelector('.hack-header');
  headerElem.addEventListener('mousedown', (e) => {
    let shiftX = e.clientX - hackPanelElem.getBoundingClientRect().left;
    let shiftY = e.clientY - hackPanelElem.getBoundingClientRect().top;

    function moveAt(pageX, pageY) {
      hackPanelElem.style.left = pageX - shiftX + 'px';
      hackPanelElem.style.top = pageY - shiftY + 'px';
    }

    function onMouseMove(e) { moveAt(e.pageX, e.pageY); }

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', ()=>document.removeEventListener('mousemove', onMouseMove), { once:true });
    hackPanelElem.ondragstart = () => false;
  });

  window.toggleHack = function(feature, event) {
    event.stopPropagation();
    hackSettings[feature] = !hackSettings[feature];
    const toggle = event.target;
    toggle.classList.toggle('active');
    const status = toggle.parentElement.querySelector('.hack-status');
    status.textContent = hackSettings[feature] ? 'ƒê√£ b·∫≠t' : 'ƒê√£ t·∫Øt';
    status.classList.add('status-update');
    setTimeout(() => status.classList.remove('status-update'), 1000);

    switch (feature) {
      case 'blockAndFixAwk':
        if (hackSettings[feature]) {
          // B·∫≠t ch·ª©c nƒÉng ch·∫∑n + fix awaken
          const waitGameLoad = setInterval(() => {
            if (
              typeof window.STORAGE === 'object' &&
              typeof window.PHP === 'object' &&
              STORAGE.hero_bou && STORAGE.tower_bou
            ) {
              clearInterval(waitGameLoad);
              console.log('[HACK] Ch·∫∑n & Fix Awaken ƒë√£ b·∫≠t.');

              // Ch·∫∑n g·ª≠i d·ªØ li·ªáu hero/tower/item/charbook
              PHP.put_userinfo_hero = (data) => console.log("[Ch·∫∑n]block Hero data:", data);
              PHP.put_userinfo_tower = (data) => console.log("[Ch·∫∑n]block Tower data:", data);
              PHP.put_userinfo_item = (n) => { console.log("[Ch·∫∑n]block Item:", n); PHP.RETRY.put_userinfo_item.count=0; };
              PHP.put_userinfo_charbook = (n) => { console.log("[Ch·∫∑n]block Charbook:", n); PHP.RETRY.put_userinfo_charbook.count=0; };

              // Fix Hero level
              // M·ªü kh√≥a t·∫•t c·∫£ hero
              for (let i = 1; i < 52; i++) {
                STORAGE.hero_bou[i].buy = 1;
                STORAGE.hero_bou[i].killexp = 1e10;
              }

              // C·∫≠p nh·∫≠t level cho c√°c hero theo nh√≥m
              for (let i = 1; i < 31; i++) {
                STORAGE.hero_bou[i].level = 50;
              }

              for (let i = 31; i < 37; i++) {
                STORAGE.hero_bou[i].level = 50;
              }

              for (let i = 37; i < 43; i++) {
                STORAGE.hero_bou[i].level = 60; // n·∫øu mu·ªën, ch·ªânh level ri√™ng cho nh√≥m n√†y
              }

              for (let i = 43; i < 46; i++) {
                STORAGE.hero_bou[i].level = 50;
              }

              for (let i = 46; i < 52; i++) {
                STORAGE.hero_bou[i].level = 60;
              }

              // Fix Awakening
              if (typeof HERO_AWAKE !== "undefined") {
                HERO_AWAKE.can_awawkening_gold = 0;
                HERO_AWAKE.can_awawkening_magic = 0;
                HERO_AWAKE.can_breaking_gold = 0;
                HERO_AWAKE.can_breaking_magic = 0;
                HERO_AWAKE.can_fenrir_change_color = 0;
              }

              // Fix upgrade
              for (let i = 1; i < 4; i++) STORAGE.upgrade[i] = 50;

              // Fix charbook
              for (let i = 1; i < 53; i++) STORAGE.charbook.hero[i] = 1;
              for (let i = 1; i < 267; i++) STORAGE.charbook.monster[i] = 1;
            }
          }, 1000);
          window.blockAndFixAwkInterval = waitGameLoad;

        } else {
          // T·∫Øt ch·ª©c nƒÉng
          clearInterval(window.blockAndFixAwkInterval);
          console.log('üôÇ Ch·∫∑n & Fix Awaken ƒë√£ t·∫Øt.');
        }
      break;

      case 'eventMods':
        eventMods = hackSettings[feature];
        eventMods ? (HackEventShopManager.apply(), setInterval(hackEventScan, 1000)) : (HackEventShopManager.disable(), clearInterval(hackEventScan));
        break;
      case 'speedGachaMods':
        speedGachaMods = hackSettings[feature];
        if (speedGachaMods) {
          HackSpeedManager.apply();
          if (typeof S_GACHA_COMPLETE !== "undefined" && S_GACHA_COMPLETE.get_tower_pick && !originalGachaFn) {
            originalGachaFn = S_GACHA_COMPLETE.get_tower_pick;
            S_GACHA_COMPLETE.get_tower_pick = () => [6025, 6026, 6027, 6034, 6035, 6036][Math.floor(Math.random() * 6)];
            console.log("üéØ Gacha hook ready!");
          }
        } else {
          HackSpeedManager.disable();
          if (originalGachaFn && typeof S_GACHA_COMPLETE !== "undefined" && S_GACHA_COMPLETE.get_tower_pick) {
            S_GACHA_COMPLETE.get_tower_pick = originalGachaFn;
            originalGachaFn = null;
          }
        }
        break;
      case 'shopPvpMods':
        shopPvpMods = hackSettings[feature];
        shopPvpMods ? (overrideStore(), overridePVPFunc()) : (restoreStore(), restorePVPFunc());
        break;
      case 'towerMods':
        towerMods = hackSettings[feature];
        towerMods ? applyTowerMods() : disableTowerMods();
        break;
      case 'heroMods':
        heroMods = hackSettings[feature];
        heroMods ? HeroManager.enable() : HeroManager.disable();
        break;
      case 'lokiPassAndHackMap':
        lokiPassAndHackMap = hackSettings[feature];
        if (lokiPassAndHackMap) {
          lokiPassBypass.apply();
          HackMap.apply();
        } else {
          lokiPassBypass.disable();
          HackMap.disable();
        }
        break;
      case 'monthlyPackageAndBypass':
        monthlyPackageAndBypass = hackSettings[feature];
        if (monthlyPackageAndBypass) {
          BypassNetWork.apply();
        } else {
          BypassNetWork.disable();
        }
        break;
    }
  };
})();
const origWarn = console.warn;
console.warn = function(...args) {
    if (ignoredViolations.some(v => args[0]?.includes(v))) return;
    origWarn.apply(console, args);
};
(function () {
    'use strict';

    const log = (msg) => console.log('[HACK]', msg);

    const waitGameLoad = setInterval(() => {
        if (
        typeof window.STORAGE === 'object' &&
        typeof window.PHP === 'object' &&
        STORAGE.hero_bou && STORAGE.tower_bou
        ) {
        clearInterval(waitGameLoad);
        log('ƒê√£ ph√°t hi·ªán STORAGE & PHP, b·∫Øt ƒë·∫ßu hack...');

        // 1. Ch·∫∑n g·ª≠i d·ªØ li·ªáu l√™n server
        PHP.put_userinfo_hero = (data) => {
            console.log("[DEBUG] Hero data b·ªã ch·∫∑n:", data);
            console.log("[DEBUG] Hero JSON:", JSON.stringify(data, null, 2));
            log("Ch·∫∑n g·ª≠i hero.");
        };

        PHP.put_userinfo_tower = (data) => {
            console.log("[DEBUG] Tower data b·ªã ch·∫∑n:", data);
            console.log("[DEBUG] Tower JSON:", JSON.stringify(data, null, 2));
            log("Ch·∫∑n g·ª≠i tower.");
        };

        PHP.put_userinfo_item = function(n) {
            console.log("[Bypass] Blocked put_userinfo_item, comment:", n);
            // gi·∫£ l·∫≠p response OK
            PHP.RETRY.put_userinfo_item.count = 0;
            util.log("userinfo_item data Ï†ÄÏû•ÏÑ±Í≥µ (fake)");
        };

        PHP.put_userinfo_charbook = function(n) {
            onsole.log("[Bypass] Blocked put_userinfo_charbook, comment:", n);
            PHP.RETRY.put_userinfo_charbook.count = 0;
            util.log("userinfo_charbook data Ï†ÄÏû•ÏÑ±Í≥µ (fake)");
        };
    }
  }, 1000);
})();
(function() {
    // backup h√†m c≈©
    var oldRun = S_LEVELUP_TOWER.menu_run_run;

    S_LEVELUP_TOWER.menu_run_run = function() {
        var focus = S_MAKETEAM_TOWER.bou_focus;
        var n = STORAGE.tower_bou[focus].tower_bunho_g;
        var u = STORAGE.tower_bou[focus].level;
        var f = STORAGE.tower_bou[focus].card;
        var i = CAL.get_card_levelup(n, u);
        var r = S_GAME.tower_get_grade(n);

        // B·ªè qua check rank S/A/B
        if (S_LEVELUP_TOWER.focus === 2) {
            if (STORAGE.tower_rainbow_card <= 0) {
                $(".focus").css({display: "none"});
                ChangeScene.start(glo.scene.cur, glo.S.POPUPYN, S_POPUPYN, ChangeScene.TYPE_POPUP);
                return;
            }
            // ‚ùå xo√° ƒëo·∫°n ch·∫∑n r == S/A/B
            if (i <= f) {
                util.notice(TXT.levelup_ok_not_use_rainbow, 1.5);
                glo.enable_key = 1;
                return;
            }
            $(".focus").css({display: "none"});
            ChangeScene.start(glo.scene.cur, glo.S.POPUPYN, S_POPUPYN, ChangeScene.TYPE_POPUP);
            return;
        }

        // C√°c case kh√°c gi·ªØ nguy√™n logic c≈©
        return oldRun.apply(this, arguments);
    };
})();
(function () {
       'use strict';

       // Ghi ƒë√® S_PROOFTOP.init_var

       (function() {
         'use strict';

         function overrideErrorPopupStart() {
            if (window.S_ERROR_POPUP && typeof S_ERROR_POPUP === 'object') {
             S_ERROR_POPUP.start = function(type, comment) {
               console.log('[FixAll] Blocked S_ERROR_POPUP.start call:', type, comment);
               // Kh√¥ng l√†m g√¨ c·∫£ => kh√¥ng hi·ªán popup, kh√¥ng x·ª≠ l√Ω blacklist, ...
             };
             console.log('[FixAll] Successfully overridden S_ERROR_POPUP.start');
             return true;
            }
            return false;
          }

          function tryOverride() {
            if (!overrideErrorPopupStart()) {
              setTimeout(tryOverride, 200); // N·∫øu ch∆∞a load S_ERROR_POPUP th√¨ ch·ªù th·ª≠ l·∫°i
            }
          }

          tryOverride();

        })();

        (function () {
            'use strict';

            const fakeResponse = JSON.stringify({
                COMMENT: "empty",
                RESULT: "NONE",
                VALUE: "NONe"
            });

            const origOpen = XMLHttpRequest.prototype.open;
            const origSend = XMLHttpRequest.prototype.send;

            XMLHttpRequest.prototype.open = function (method, url) {
                this._targetURL = url;
                return origOpen.apply(this, arguments);
            };

            XMLHttpRequest.prototype.send = function (body) {
                if (this._targetURL && this._targetURL.includes("put_userinfo_hero_AES2.php")) {
                   this.addEventListener("readystatechange", function () {
                        if (this.readyState === 4 && this.status === 200) {
                            Object.defineProperty(this, "responseText", {
                                get: () => fakeResponse
                            });
                            Object.defineProperty(this, "response", {
                               get: () => fakeResponse
                            });
                        }
                    });
                }
                return origSend.apply(this, arguments);
            };
        })();

        (function () {
           ' use strict';

            // Ghi ƒë√® S_PROOFTOP.init_var
            const wait_prooftop = setInterval(() => {
                if (typeof S_PROOFTOP !== 'undefined' && typeof S_PROOFTOP.init_var === 'function') {
                    clearInterval(wait_prooftop);
                    console.log("‚úÖ S_PROOFTOP ph√°t hi·ªán. Ghi ƒë√® init_var...");

                    S_PROOFTOP.init_var = function() {
                        S_PROOFTOP.row_focus = 2;
                        S_PROOFTOP.btn_focus = 2;
                        S_PROOFTOP.top_focus = 1;
                        S_PROOFTOP.NUM = S_PROOFTOP.clear_reward.length - 1;
                        console.log("üèÜ S_PROOFTOP: clear_reward ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t");
                    };

                    if (typeof S_PROOFTOP.clear_reward !== 'undefined') {
                        S_PROOFTOP.init_var();
                    }
                }
            }, 1000);

            // Ghi ƒë√® S_DAYTRY.init_var
            const wait_daytry = setInterval(() => {
                if (typeof S_DAYTRY !== 'undefined' && typeof S_DAYTRY.init_var === 'function') {
                    clearInterval(wait_daytry);
                    console.log("‚úÖ S_DAYTRY ph√°t hi·ªán. Ghi ƒë√® reward...");

                    S_DAYTRY.init_var = function() {
                        S_DAYTRY.focus = 2;
                        S_DAYTRY.message[1] = TXT.realtime_borad_comment;
                        S_DAYTRY.reward = [
                           {},
                           { type: "MAGIC", value: 10000, plus: 0.3 },
                           { type: "MAGIC", value: 10000, plus: 0.1 },
                           { type: "MAGIC", value: 10000, plus: 0.02 }
                        ];
                       console.log("üéÅ S_DAYTRY: reward ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t ch·ªâ c√≤n MAGIC.");
                    };

                    if (typeof S_DAYTRY.reward !== 'undefined') {
                       S_DAYTRY.init_var();
                    }
                }
            }, 1000);
        })();
    })();
(function() {
  // Hook fetch
  const originalFetch = window.fetch;
  window.fetch = async (...args) => {
    if (typeof args[0] === "string" && args[0].includes("stage")) {
      console.log("‚õî Blocked stage fetch:", args[0]);
      // Tr·∫£ response r·ªóng ƒë·ªÉ game kh√¥ng treo
      return new Response("{}", {
        status: 200,
        headers: { "Content-Type": "application/json" }
      });
    }
    return originalFetch(...args);
  };

  // Hook XHR
  const open = XMLHttpRequest.prototype.open;
  XMLHttpRequest.prototype.open = function(method, url) {
    if (url.includes("stage")) {
      console.log("‚õî Blocked stage XHR:", url);
      this.send = () => {}; // v√¥ hi·ªáu h√≥a send
    }
    return open.apply(this, arguments);
  };

  // Hook WebSocket
  const send = WebSocket.prototype.send;
  WebSocket.prototype.send = function(data) {
    try {
      const text = data.toString();
      if (text.includes("stage")) {
        console.log("‚õî Blocked stage WS:", text);
        return; // kh√¥ng g·ª≠i g√¨
      }
    } catch (e) {}
    return send.apply(this, arguments);
  };
})();
(function () {
    'use strict';

    console.log("üöÄ Strong Blacklist Bypass Loaded!");

    // ========== 1. Hook util.get_decryt2 ==========
    const interval = setInterval(() => {
        if (typeof util !== 'undefined' && typeof util.get_decryt2 === 'function') {
            clearInterval(interval);

            const original = util.get_decryt2;
            util.get_decryt2 = function (input) {
                const decrypted = original.call(this, input);

                try {
                    const json = JSON.parse(decrypted);
                    if (json?.VALUE?.black_list) {
                        json.VALUE.black_list.result = "NONE";
                        json.VALUE.black_list.value = "Bypassed by get_decryt2";
                        console.log("‚úÖ Bypass blacklist at decryt2!");
                    }
                    return JSON.stringify(json);
                } catch (e) {
                    return decrypted;
                }
            };
        }
    }, 500);

    // ========== 2. Hook S_ERROR_POPUP.start ==========
    const popupInterval = setInterval(() => {
        if (typeof S_ERROR_POPUP !== "undefined" && typeof S_ERROR_POPUP.start === "function") {
            clearInterval(popupInterval);

            const origStart = S_ERROR_POPUP.start;
            S_ERROR_POPUP.start = function(type, comment) {
                if (type === S_ERROR_POPUP.TYPE.BLACK_LIST) {
                    console.warn("‚ùå BLACK_LIST popup blocked!");
                    return; // ch·∫∑n lu√¥n
                }
                return origStart.call(this, type, comment);
            };
        }
    }, 500);

    // ========== 3. Hook fetch (backup cu·ªëi c√πng) ==========
    const origFetch = window.fetch;
    window.fetch = async function(resource, options) {
        const res = await origFetch(resource, options);

        const text = await res.clone().text();
        let modified = text;

        try {
            const json = JSON.parse(text);
            if (json?.VALUE?.black_list?.result === "BLACK_LIST") {
                json.VALUE.black_list.result = "NONE";
                json.VALUE.black_list.value = "Bypassed at fetch";
                modified = JSON.stringify(json);
                console.log("üî• Blacklist patched at fetch layer!");
            }
        } catch (e) {
            // kh√¥ng ph·∫£i JSON th√¨ b·ªè qua
        }

        return new Response(modified, {
            status: res.status,
            statusText: res.statusText,
            headers: res.headers
        });
    };

})();
